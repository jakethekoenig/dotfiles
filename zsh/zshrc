git_branch() {
    local branch=$(git branch 2>/dev/null | grep '^*' | colrm 1 2)
    if [ ! -z $branch ]; then
        local staged=$(git diff --cached --quiet; echo $?)
        local unstaged=$(git diff --quiet; echo $?)
        
        if [ $staged -eq 1 ]; then
            color="green"
        else
            color="cyan"
        fi
        
        local suffix=""
        if [ $unstaged -eq 1 ]; then
            suffix="*"
        fi
        
        echo " %F{$color}(ðŸŒ³ $branch$suffix)%f"
    fi
}

aws_profile() {
if [ ! -z $AWS_PROFILE ]; then
echo "%F{208}(AWS:$AWS_PROFILE)%f"
fi
}

butler_env() {
if [ ! -z $BUTLER_ENVIRONMENT ]; then
echo "%F{208}(ENV:$BUTLER_ENVIRONMENT)%f"
fi
}

# Create or switch to a git worktree
wt() {
  if [ -z "$1" ]; then
    echo "Usage: wt <branch> [<start-point>]" >&2
    return 1
  fi

  local branch="$1"
  shift

  local repo_root
  repo_root=$(git rev-parse --show-toplevel 2>/dev/null) || {
    echo "wt: not inside a git repository" >&2
    return 1
  }

  local repo_name
  repo_name=$(basename "$repo_root")
  local worktree_root="$HOME/worktrees/$repo_name"
  local worktree_path="$worktree_root/$branch"

  # Check if the branch is already checked out somewhere
  local existing_path=""
  local current_worktree=""
  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        current_worktree="${line#worktree }"
        ;;
      branch\ *)
        local worktree_branch="${line#branch refs/heads/}"
        if [ "$worktree_branch" = "$branch" ]; then
          existing_path="$current_worktree"
          break
        fi
        ;;
    esac
  done < <(git worktree list --porcelain)

  if [ -n "$existing_path" ]; then
    echo "wt: switching to existing worktree at $existing_path" >&2
    cd "$existing_path"
    return 0
  fi

  if [ -e "$worktree_root" ] && [ ! -d "$worktree_root" ]; then
    echo "wt: $worktree_root exists and is not a directory" >&2
    return 1
  fi

  mkdir -p "$worktree_root" || return $?

  if [ -e "$worktree_path" ]; then
    if [ ! -d "$worktree_path" ]; then
      echo "wt: $worktree_path exists and is not a directory" >&2
      return 1
    fi
    if [ -d "$worktree_path/.git" ] || [ -f "$worktree_path/.git" ]; then
      echo "wt: $worktree_path already looks like a git worktree; aborting" >&2
      return 1
    fi
  fi

  local force_flag=()
  if [ -d "$worktree_path" ]; then
    if [ -n "$(ls -A "$worktree_path" 2>/dev/null)" ]; then
      echo "wt: $worktree_path already exists and is not empty" >&2
      return 1
    fi
    force_flag=(--force)
  fi

  if git show-ref --verify --quiet "refs/heads/$branch"; then
    git worktree add "${force_flag[@]}" "$worktree_path" "$branch" || return $?
  else
    git worktree add "${force_flag[@]}" -b "$branch" "$worktree_path" "$@" || return $?
  fi

  # Create symlinks for common dependency directories if they exist in the main repo
  # Use git-common-dir to get the main repo root (not current worktree)
  local main_repo_root
  main_repo_root="$(git rev-parse --git-common-dir)"
  main_repo_root="${main_repo_root%/.git}"  # Strip /.git suffix

  for dir in node_modules venv .venv; do
    local target="$main_repo_root/$dir"
    # Only symlink if target is a real directory (not a symlink) and exists
    if [ -d "$target" ] && [ ! -L "$target" ] && [ ! -e "$worktree_path/$dir" ]; then
      ln -s "$target" "$worktree_path/$dir"
      echo "wt: created symlink for $dir" >&2
    fi
  done

  cd "$worktree_path"
}
gwtr() {
  if [ -z "$1" ]; then
    echo "Usage: gwtr <branch> [--force]" >&2
    return 1
  fi

  local branch="$1"
  shift

  local repo_root
  repo_root=$(git rev-parse --show-toplevel 2>/dev/null) || {
    echo "gwtr: not inside a git repository" >&2
    return 1
  }

  local repo_name
  repo_name=$(basename "$repo_root")
  local worktree_root="$HOME/worktrees/$repo_name"
  local worktree_path="$worktree_root/$branch"

  if [ ! -d "$worktree_path" ]; then
    echo "gwtr: no worktree at $worktree_path" >&2
    return 1
  fi

  git worktree remove "$worktree_path" "$@"
}


setopt PROMPT_SUBST
PROMPT='%F{blue}â•­â”€%f%F{cyan}%~%f$(aws_profile)$(butler_env)$(git_branch)%F{green}${VIRTUAL_ENV:+ (ðŸ $(basename $(dirname ${VIRTUAL_ENV}))/$(basename ${VIRTUAL_ENV}))}%f
%F{blue}â•°â”€%f%F{red}%(!.#.$)%f '

setopt histignorealldups sharehistory

export TERM=screen-256color
export PYTHONSTARTUP=~/.python_profile.py
export VIRTUAL_ENV_DISABLE_PROMPT=1
export EDITOR=nvim

# Vim is life! TODO: quickly port keybindings from my vimrc to my zshrc?
bindkey -v
bindkey jk vi-cmd-mode

# Keep 1000 lines of history within the shell and save it to ~/.zsh_history:
HISTSIZE=100000
SAVEHIST=100000
HISTFILE=~/.zsh_history

# Use modern completion system
autoload -Uz compinit
compinit -u

# Completion functions for wt and gwtr
_wt() {
  local -a branches
  branches=(${(f)"$(git branch --all --format='%(refname:short)' 2>/dev/null | sed 's#^origin/##')"})
  _describe 'branch' branches
}

_gwtr() {
  local -a branches
  branches=(${(f)"$(git branch --format='%(refname:short)' 2>/dev/null)"})
  _describe 'branch' branches
}

compdef _wt wt
compdef _gwtr gwtr

# TODO: understand zstyle better.
zstyle ':completion:*' auto-description 'specify: %d'
zstyle ':completion:*' completer _expand _complete _correct _approximate
zstyle ':completion:*' format 'Completing %d'
zstyle ':completion:*' group-name ''
zstyle ':completion:*' menu select=2
# eval "$(dircolors -b)"
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' list-prompt %SAt %p: Hit TAB for more, or the character to insert%s
zstyle ':completion:*' matcher-list '' 'm:{a-z}={A-Z}' 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=* l:|=*'
zstyle ':completion:*' menu select=long
zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
zstyle ':completion:*' use-compctl false
zstyle ':completion:*' verbose true

zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;31'
zstyle ':completion:*:kill:*' command 'ps -u $USER -o pid,%cpu,tty,cputime,cmd'

# Shorthands
alias v='nvim'
alias py='python3 -q'
alias ls='ls --color'
export CLICOLOR=1
export LSCOLORS=GxFxCxDxBxegedabagaced

# These names are chosen to match my vim short hands standing for 'edit vimrc', 'source vimrc'
alias ev='v ~/.zshrc'
alias lv='v ~/.zsh/local.zsh'
alias sv='source ~/.zshrc'
alias slv='source ~/.zsh/local.zsh'
alias :q='exit'
alias q='exit'

for conf in "$HOME/.zsh/"*.zsh; do
  source "${conf}"
done
unset conf

alias gs='git status'
alias gst='git stash'
alias gc='git commit'
alias gr='git restore'
alias gco='git checkout'
alias ghco='gh pr checkout'
ghw() {
  if [ -z "$1" ]; then
    # No arguments - try to open PR for current branch
    gh pr view --web
    return $?
  fi

  # Try to view as PR first
  if gh pr view "$1" &>/dev/null; then
    gh pr view --web "$1"
  else
    # If not a PR, view as issue
    gh issue view --web "$1"
  fi
}
alias ghl='gh pr list'
alias ga='git add'
alias gd='git --no-pager diff --no-prefix'
alias gds='git --no-pager diff --staged --no-prefix'
alias gp='git pull'
alias gpu='git push'
alias gl='git log'

export PATH="/home/jake/.local/bin":$PATH

[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

#export NVM_DIR="$HOME/.nvm"
#[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
#[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

# bun completions
#[ -s "/Users/jakekoenig/.bun/_bun" ] && source "/Users/jakekoenig/.bun/_bun"

# bun
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"

# amp
export PATH="$HOME/.local/bin:$PATH"
